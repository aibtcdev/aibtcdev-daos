# Template System Refinement Plan

## Goal

The primary goal is to improve the clarity, robustness, and maintainability of the Stacks contract template variable system. This involves:

1.  Ensuring the `TemplateScanner` accurately distinguishes between:
    *   Template variables whose values are known and generated by the system (derived from known traits, addresses, contract names).
    *   Custom/runtime template variables whose values are expected to be provided ad-hoc during contract generation.
2.  Making all template variable dependencies fully explicit for each contract.
3.  Reducing `TemplateScanner` noise by ensuring its reports accurately reflect intended configurations.

## Key Principles

1.  **Explicit Dependency Declaration**: All template variables (`keyName` from `;; /g/toReplace/keyName` comments) used by a contract template *must* be explicitly declared as a dependency for that contract in `utilities/contract-dependencies.ts`.
    *   Known addresses, traits, or contract cross-references are declared using `addAddressDependency()`, `addTraitDependency()`, or `addContractDependency()` respectively.
    *   Truly custom/runtime variables (those not automatically generated by `utilities/template-variables.ts`) must be declared using `addRuntimeValue("your_custom_key_name")`.
2.  **Role of `ContractBase.scanTemplateVariables`**: This method in `models/contract-template.ts` will no longer automatically register all found template variables as runtime dependencies. Its purpose is to parse variables from template content, which can be utilized by tools like the `TemplateScanner` or `ContractGeneratorService`, but it does not modify the `ContractBase` instance's dependency lists.
3.  **Source of Truth for Known Variables**: `utilities/template-variables.ts` (specifically `generateTemplateReplacements()`) is the central place where all system-known replacement values are generated. The `TemplateScanner` uses the keys from this output as the "master list" of known `keyName`s.

## Relevant Files

The following files are central to the template system and will be involved in this refinement:

*   **Core Logic & Definitions**:
    *   `models/contract-template.ts`: Defines `ContractBase`, its dependency properties (`requiredAddresses`, `requiredTraits`, etc.), methods for adding dependencies (`addAddressDependency`, etc.), and `scanTemplateVariables`.
    *   `utilities/contract-types.ts`: Defines `ContractType`, `ContractSubtype`, and `CONTRACT_NAMES` (used as a source for contract name variables).
    *   `utilities/known-addresses.ts`: Defines known wallet/contract addresses for different networks.
    *   `utilities/known-traits.ts`: Defines known trait references for different networks.
*   **Variable Generation & Processing**:
    *   `utilities/template-variables.ts`: Contains `generateTemplateReplacements()` which creates the map of all known replacement `keyName`s and their values.
    *   `utilities/template-processor.ts`: Contains `processContractTemplate()` which performs the actual string replacements in template content.
*   **Dependency Declaration**:
    *   `utilities/contract-dependencies.ts`: Contains functions like `defineAllDaoContractDependencies()` that explicitly declare which `keyName`s each contract requires.
*   **Validation & Tooling**:
    *   `utilities/template-scanner.ts`: The linting tool (`TemplateScanner` class) that validates templates against known variables and declared dependencies.
    *   `scripts/run-template-scanner.ts`: The executable script to run the `TemplateScanner`.
    *   `package.json`: Contains the `lint:templates` npm script.
*   **Templates**:
    *   All `.clar` files under the `contracts/` directory.

## Tasks

1.  **Modify `ContractBase.scanTemplateVariables`** (Done in commit `985e9d2` - verify if previous change was this one, or if this is the one from the last user message):
    *   **File**: `models/contract-template.ts`
    *   **Action**: Ensure `scanTemplateVariables` no longer calls `this.addTemplateVariable()` or otherwise automatically adds all scanned variables from template comments to the `requiredRuntimeValues` list. Its role is to parse, not to declare dependencies on the instance.
    *   **Rationale**: Makes dependency declaration fully explicit via `utilities/contract-dependencies.ts`.

2.  **Review `ContractBase.addTemplateVariable`**:
    *   **File**: `models/contract-template.ts`
    *   **Action**: Assess if `addTemplateVariable` is still used by any part of the system after the change to `scanTemplateVariables`. If it's exclusively called by the old `scanTemplateVariables` logic, it might be redundant for dependency management.
    *   **Note**: For now, this method can remain, but its role in populating `ContractBase` dependencies is diminished.

3.  **Systematically Update `utilities/contract-dependencies.ts`**:
    *   **Action**: Iterate through each `.clar` template file. For every `;; /g/toReplace/keyName` comment:
        *   Identify the `keyName`.
        *   Determine if this `keyName` represents a known address, trait, contract reference, or a truly custom/runtime value.
        *   Ensure the corresponding explicit declaration exists in `utilities/contract-dependencies.ts` for the specific contract using that template:
            *   `contract.addAddressDependency("KNOWN_ADDRESS_KEY", "keyName_from_template")`
            *   `contract.addTraitDependency("KNOWN_TRAIT_KEY", "keyName_from_template")`
            *   `contract.addContractDependency("keyName_from_template", "TYPE", "SUBTYPE")`
            *   `contract.addRuntimeValue("keyName_from_template")` (for custom/runtime values not covered above).
    *   **Rationale**: This ensures every variable used in a template is explicitly accounted for as a dependency of that contract.

4.  **Refine `utilities/template-variables.ts`**:
    *   **Action**: Review the `keyName`s reported as `UnknownKeyName` by the `TemplateScanner`.
    *   For each such `keyName`:
        *   If it *should* be a system-known variable (e.g., a standard trait reference, a common contract alias, a patterned agent trait), add or correct the logic within `generateTemplateReplacements()` to produce this `keyName` and its corresponding replacement value.
        *   Ensure that both the simple `keyName` and any `toReplace/keyName` composite keys are generated if `processContractTemplate` or other parts of the system rely on these composite forms for lookup.
    *   **Rationale**: Ensures the master list of "known" variables is complete and accurate.

5.  **Iteratively Run `TemplateScanner` and Refine Dependencies**:
    *   **Action**: After making changes in steps 3 and 4, run `npm run lint:templates`.
    *   Analyze the `TemplateScanner` output:
        *   **`UnknownKeyName` errors**: These point to `keyName`s used in templates that are not being generated by `utilities/template-variables.ts`. Address these by updating `template-variables.ts` (Task 4).
        *   **`UndeclaredDependency` errors**: These point to `keyName`s used in a template that are known (i.e., generated by `template-variables.ts`) but have not been explicitly declared for that *specific contract* in `utilities/contract-dependencies.ts`. Address these by updating `contract-dependencies.ts` (Task 3).
    *   Repeat this cycle until the `TemplateScanner` reports no issues, or only issues that are understood and accepted.

6.  **(Future Consideration) Strongly Type `keyName`s**:
    *   **Action**: Re-evaluate introducing a `TemplateKeyName` TypeScript string literal union type, derived from the keys generated by `getAllKnownTemplateVariables()`.
    *   If pursued, apply this type to:
        *   The `key` parameter in `ContractBase` methods (`addAddressDependency`, `addTraitDependency`, `addContractDependency`, `addRuntimeValue`).
        *   The keys in the `Record` returned by `generateTemplateReplacements` in `utilities/template-variables.ts`.
        *   Relevant parameters and variables in `utilities/contract-dependencies.ts` and `utilities/template-processor.ts`.
    *   **Rationale**: Enhances type safety and catches errors related to `keyName` mismatches at compile time.

This plan aims to make the template variable system more predictable and easier to debug by enforcing explicit declarations and leveraging the `TemplateScanner` as a key validation tool.
